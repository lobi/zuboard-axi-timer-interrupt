# Zynq UltraScale+ Interrupt Demo - ZUBoard 1CG

Complete Vivado + Vitis project demonstrating interrupt-driven programming on Zynq UltraScale+ MPSoC using AXI Timer peripherals in the Programmable Logic (PL).

## Overview

This project demonstrates PS-PL interrupt communication on the Zynq UltraScale+ platform:
- **Vivado Hardware Design**: AXI peripherals in Programmable Logic (PL)
- **Vitis Software**: Bare-metal C application running on ARM Cortex-A53 (PS)
- **Interrupt Flow**: PL Timer → PS GIC → CPU Exception Handler

## Hardware Platform

- **Board**: ZUBoard 1CG (xczu1cg)
- **SoC**: Zynq UltraScale+ MPSoC (xczu1cg-sbva484-1-e)
- **PS**: ARM Cortex-A53 Quad-Core @ 1.2 GHz
- **PL**: Artix-7 based Programmable Logic

## Project Structure

```
interrupt/
├── interrupt.xpr                 # Vivado project
├── design_1_wrapper.xsa         # Exported hardware specification
├── interrupt.srcs/              # Vivado source files
│   └── sources_1/bd/design_1/   # Block design
└── vitis_irq/                   # Vitis workspace
    ├── platform2/               # Hardware platform
    │   ├── hw/                  # XSA import
    │   └── export/              # BSP exports
    └── hello_world2/            # Main interrupt demo
        └── src/
            └── helloworld.c     # Timer interrupt application
```

## Programmable Logic (PL) Design

### Block Design - design_1

![Block Design](/docs/vivado-bd.png)

The Vivado block design implements the following PL peripherals:

#### IP Blocks

| IP Core | Instance Name | Version | Purpose |
|---------|---------------|---------|---------|
| **Zynq UltraScale+ MPSoC** | zynq_ultra_ps_e_0 | 3.5 | Processing System with ARM cores |
| **AXI Timer** | axi_timer_0 | 2.0 | 32-bit timer/counter for periodic interrupts |
| **AXI GPIO** | axi_gpio_0 | 2.0 | General Purpose I/O (LED/Switch interface) |
| **AXI GPIO** | axi_gpio_1 | 2.0 | Additional GPIO port |
| **AXI SmartConnect** | axi_smc | 1.0 | AXI interconnect for M_AXI_HPM0_LPD |
| **Processor System Reset** | rst_ps8_0_100M | 5.0 | Synchronized reset generation |

#### AXI Timer Configuration

- **Base Address**: 0x80020000
- **Address Range**: 0x80020000 - 0x8002FFFF (64KB)
- **Clock Frequency**: 100 MHz
- **Counter Width**: 32-bit
- **Number of Timers**: 2 (using Timer 0)
- **Interrupt Output**: Connected to pl_ps_irq[0] (IRQ 89)

#### Memory Map

| Peripheral | Base Address | Size | Description |
|-----------|--------------|------|-------------|
| axi_timer_0 | 0x80020000 | 64KB | Timer/Counter registers |
| axi_gpio_0 | 0x80000000 | 64KB | GPIO Channel 1 & 2 |
| axi_gpio_1 | 0x80010000 | 64KB | GPIO Channel 1 & 2 |

#### AXI Interconnect

```
PS M_AXI_HPM0_LPD (64-bit @ 100 MHz)
    └─ AXI SmartConnect (axi_smc)
        ├─ axi_timer_0   [S00_AXI]
        ├─ axi_gpio_0    [S01_AXI]
        └─ axi_gpio_1    [S02_AXI]
```

#### Interrupt Routing

```
PL → PS Interrupt Path:

axi_timer_0.interrupt
    └─ zynq_ultra_ps_e_0.pl_ps_irq[0]
        └─ GIC Interrupt ID: 89 (0x59)
            └─ CPU Exception Handler
                └─ TimerCounterHandler()
```

### Clocking & Reset

- **PS Clock**: pl_clk0 = 100 MHz (generated by PS)
- **PL Reset**: Synchronized by rst_ps8_0_100M module
- **AXI Clock**: All AXI peripherals operate at 100 MHz

## Vitis Software Applications

### hello_world2 - Main Interrupt Demo

![Block Design](/docs/vitis-output.png)

Custom implementation demonstrating:
- AXI Timer initialization using base address (SDT platform)
- Interrupt setup with `XSetupInterruptSystem()` wrapper
- Down-count timer mode with auto-reload
- 1-second periodic interrupts (100M cycles @ 100 MHz)
- Interrupt handler counting 10 events then stopping

**Key Features:**
- Hardware register diagnostics
- Timer counter validation
- Proper SDT platform interrupt configuration
- Clean separation of initialization and ISR logic

**Files:**
- `helloworld.c` - Main application with interrupt handling
- `platform.c/h` - Platform initialization
- `lscript.ld` - Linker script for Cortex-A53

### hello_world - Reference Example

Unmodified Xilinx `xtmrctr_intr_example.c` for comparison.

## Building the Project

### Prerequisites

- **Vivado 2025.1** or later
- **Vitis 2025.1** or later
- **ZUBoard 1CG** with JTAG connection

### Hardware Build (Vivado)

1. **Open Vivado Project**
   ```tcl
   vivado interrupt.xpr
   ```

2. **Generate Bitstream**
   - Flow Navigator → Generate Bitstream
   - Wait for implementation to complete

3. **Export Hardware**
   - File → Export → Export Hardware
   - Include bitstream → OK
   - Exports to `design_1_wrapper.xsa`

### Software Build (Vitis)

1. **Open Vitis Workspace**
   ```bash
   vitis -workspace ./vitis_irq
   ```

2. **Update Platform** (if XSA changed)
   - Right-click `platform2` → Update Hardware Specification
   - Select new `design_1_wrapper.xsa`
   - Build platform

3. **Build Application**
   ```bash
   cd vitis_irq/hello_world2
   vitis-comp --workspace ../
   ```

   Or in Vitis IDE:
   - Right-click `hello_world2` → Build Project

### Deploy & Run

1. **Connect Hardware**
   - Connect ZUBoard via JTAG
   - Connect UART console (115200 8N1)

2. **Program FPGA & Launch**
   - Right-click `hello_world2` → Run As → Launch Hardware (Single Application Debug)
   
   Or use XSCT:
   ```tcl
   connect
   targets -set -filter {name =~ "Cortex-A53 #0"}
   fpga design_1_wrapper.bit
   dow hello_world2/build/hello_world2.elf
   con
   ```

## Expected Output

```
===================================
AXI TIMER INTERRUPT DEMO - ZUBoard 1CG
===================================
Timer Base Address: 0x80020000
Interrupt ID: 89
GIC Device ID: 0
Timer initialized successfully
Timer self-test passed
Interrupt system configured successfully
Timer handler registered
Timer options configured (INT + AUTO_RELOAD + DOWN_COUNT)
Timer reset value set to 0x05F5E100 (~1 sec @ 100 MHz)
Timer started - waiting for interrupts...
TCSR0 (Control/Status): 0x000000D0
TCR0 (Counter Value): 0x0604944A
Expected bits: ENALL=0x80, ENIT=0x40

Testing if timer counter is incrementing...
Counter before: 0x06191BD7, after: 0x06721E74
Timer IS counting!

IRQ 1
IRQ 2
IRQ 3
IRQ 4
IRQ 5
IRQ 6
IRQ 7
IRQ 8
IRQ 9
IRQ 10

Timer stopped after 10 interrupts
Successfully ran Timer interrupt Example
```

## Technical Details

### PS-PL Interrupt Configuration

**Processing System (PS) Side:**
- **GIC (Generic Interrupt Controller)**: Routes PL interrupts to CPU
- **Interrupt ID 89**: PL-to-PS IRQ[0] mapped to timer
- **Exception Handler**: ARM CPU exception mechanism
- **Priority**: 0xA0 (160), Trigger: Rising Edge

**Programmable Logic (PL) Side:**
- **Timer Interrupt**: Generated on counter reaching zero
- **Control Register (TCSR)**: 
  - Bit 7 (ENALL=0x80): Enable timer
  - Bit 6 (ENIT=0x40): Enable interrupt
- **Auto-Reload**: Timer reloads from TLR register

### SDT Platform Differences

Modern Xilinx platforms use **SDT (System Device Tree)** approach:

| Legacy | SDT Platform |
|--------|-------------|
| `XPAR_TMRCTR_0_DEVICE_ID` | `XPAR_XTMRCTR_0_BASEADDR` |
| Manual GIC setup | `XSetupInterruptSystem()` wrapper |
| Fixed device IDs | Config struct: `.IntrId`, `.IntrParent` |

### AXI Timer Operation

```
Timer Count Sequence:
1. Load TLR (0x05F5E100 = 100M) → TCR
2. Start counting DOWN
3. TCR = TCR - 1 (every clock cycle)
4. TCR reaches 0 → Generate interrupt
5. Auto-reload: TCR ← TLR
6. Repeat from step 2
```

**Timer Control/Status Register (TCSR):**
- `0xD0` = `1101 0000` binary
  - Bit 7 (ENALL): Timer enabled
  - Bit 6 (ENIT): Interrupt enabled
  - Bit 5 (LOAD): Load timer
  - Bit 4 (ARHT): Auto-reload enabled

## Troubleshooting

### Common Issues

**Issue**: Interrupts not firing
- **Check**: TCSR register shows `0xD0` (ENALL + ENIT bits set)
- **Solution**: Add `XTC_DOWN_COUNT_OPTION` to timer configuration
- **Verify**: Use `XSetupInterruptSystem()` for SDT platforms

**Issue**: Timer not counting
- **Check**: Counter value incrementing (for up-count) or decrementing (down-count)
- **Solution**: Verify PL clock is 100 MHz and timer is started

**Issue**: Wrong interrupt ID
- **Check**: Use `XPAR_FABRIC_XTMRCTR_0_INTR` (89) not legacy vector ID
- **Verify**: Interrupt routing in block design

**Issue**: Compilation error about DEVICE_ID
- **Solution**: Use `XPAR_XTMRCTR_0_BASEADDR` instead of `XPAR_TMRCTR_0_DEVICE_ID`

### Debug Tips

1. **Check hardware registers:**
   ```c
   u32 tcsr = XTmrCtr_ReadReg(BaseAddr, 0, XTC_TCSR_OFFSET);
   u32 tcr = XTmrCtr_ReadReg(BaseAddr, 0, XTC_TCR_OFFSET);
   ```

2. **Verify interrupt routing in Vivado:**
   - Address Editor: Check timer base address
   - Block Design: Verify pl_ps_irq[0] connection

3. **Test in polling mode first:**
   ```c
   while (!XTmrCtr_IsExpired(&Timer, 0));
   ```

## References

### Xilinx Documentation
- [UG1085: Zynq UltraScale+ MPSoC TRM](https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm)
- [PG079: AXI Timer v2.0 Product Guide](https://www.xilinx.com/support/documentation/ip_documentation/axi_timer/v2_0/pg079-axi-timer.pdf)
- [PG144: AXI GPIO v2.0 Product Guide](https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf)
- [UG1137: Zynq UltraScale+ MPSoC Software Developer Guide](https://docs.xilinx.com/r/en-US/ug1137-zynq-ultrascale-mpsoc-swdev)

### BSP Documentation
- [Standalone OS BSP API](https://xilinx.github.io/embeddedsw.github.io/standalone/doc/html/api/index.html)
- [XTmrCtr Driver API](https://xilinx.github.io/embeddedsw.github.io/tmrctr/doc/html/api/index.html)
- [XScuGic Driver API](https://xilinx.github.io/embeddedsw.github.io/scugic/doc/html/api/index.html)

## License

Based on Xilinx AXI Timer interrupt example.

Copyright © 2002-2024 Xilinx, Inc. / Advanced Micro Devices, Inc. All Rights Reserved.

SPDX-License-Identifier: MIT

## Authors

- **Hardware Design**: Vivado block design for ZUBoard 1CG
- **Software**: Adapted from Xilinx xtmrctr_intr_example.c
- **Platform**: Zynq UltraScale+ MPSoC xczu1cg
